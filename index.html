<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
  <link rel="manifest" href="manifest.json">
<title>StructalGraphOperations —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ —Å–ø–∏—Ä–∞–ª—è–º–∏ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∫—Ä–∞—Å–Ω—ã—Ö —É–∑–ª–æ–≤</title>
<!-- –í <head> –ø–æ–¥–∫–ª—é—á–∞–µ–º —à—Ä–∏—Ñ—Ç -->
<link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@500;700&display=swap" rel="stylesheet">

<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
  #scaleSlider {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 200px;
    z-index: 10;
  }
/* –ù–æ–≤—ã–π —Å—Ç–∏–ª—å –º–µ–Ω—é */
#nodeMenu {
  position: absolute;
  background: linear-gradient(135deg, rgba(0,30,0,0.7), rgba(0,50,20,0.75), rgba(10,60,10,0.7));
  padding: 12px 16px;
  border-radius: 14px; /* —É–≤–µ–ª–∏—á–µ–Ω–æ —Å 10px */
  color: #fff;
  pointer-events: auto;
  display: none;
  opacity: 0;
  transform: scale(0.96);
  transform-origin: top left;
  transition: opacity 0.25s ease, transform 0.25s ease, box-shadow 0.3s ease;

  font-family: 'Exo 2', sans-serif;
  font-size: 14px;
  line-height: 1.95;
  white-space: nowrap;

  border: 2px solid transparent;
  background-clip: padding-box;
  box-shadow: 0 0 6px rgba(180,255,180,0.08), inset 0 0 4px rgba(180,255,180,0.03);
  backdrop-filter: blur(6px);
  will-change: transform;

}

#nodeMenu #nodeNameInput {
  font-weight: 700;         
  text-align: center;       
  font-size: 15px;          
  margin-bottom: 12px;
  background: rgba(0,0,0,0.45);
  border: 2px solid rgba(180,255,180,0.15);
  color: #d8ffd8;
  outline: none;
  padding: 6px 8px;
  border-radius: 10px; /* —É–≤–µ–ª–∏—á–µ–Ω–æ —Å 6px */
  transition: all 0.2s ease;
  position: relative;
  z-index: 1;
  box-shadow: 0 0 3px rgba(180,255,180,0.15), inset 0 0 2px rgba(180,255,180,0.03);
  animation: neonPulseInput 2s ease-in-out infinite;
}

#nodeMenu .menuItem {
  background: rgba(0,30,0,0.22);
  padding: 5px 6px;
  border-radius: 8px; /* —É–≤–µ–ª–∏—á–µ–Ω–æ —Å 4px */
  margin: 3px 0;
  box-shadow: 0 0 4px rgba(180,255,180,0.06), inset 0 0 2px rgba(180,255,180,0.02);
  transition: background 0.2s, box-shadow 0.2s;
  color: #ccffcc;
}

#nodeMenu .menuItem:hover {
  background: rgba(0,40,0,0.3);
  box-shadow: 0 0 8px rgba(180,255,180,0.12), inset 0 0 3px rgba(180,255,180,0.04);
}






/* –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é Add Task */
#addTaskMenu {
  position: absolute;
  background: linear-gradient(135deg, rgba(0,30,0,0.9), rgba(0,50,20,0.85), rgba(10,60,10,0.9));
  padding: 20px 25px;
  border-radius: 14px;
  color: #ccffcc;
  display: none;
  opacity: 0;
  transform: scale(0.96);
  transform-origin: top left;
  transition: opacity 0.25s ease, transform 0.25s ease;
  font-family: 'Exo 2', sans-serif;
  font-size: 14px;
  line-height: 1.6;
  width: 480px;
  max-width: 95vw;
  box-shadow: 0 0 8px rgba(180,255,180,0.12), inset 0 0 3px rgba(180,255,180,0.04);
}

/* –ü–æ–ª—è –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ –∏ textarea */
#addTaskMenu input[type="text"],
#addTaskMenu input[type="number"],
#addTaskMenu input[type="time"],
#addTaskMenu textarea,
#addTaskMenu select {
  width: 100%;
  padding: 8px 12px;
  margin-bottom: 14px;
  border-radius: 8px;
  border: 1px solid rgba(180,255,180,0.25);
  background: rgba(0,0,0,0.45);
  color: #d8ffd8;
  font-size: 13px;
  outline: none;
  box-sizing: border-box;
}

/* –ì–ª–∞–≤–Ω—ã–µ —Ä–∞–¥–∏–æ–∫–Ω–æ–ø–∫–∏: —Ç–∏–ø –∑–∞–¥–∞—á–∏ */
#taskTypeGroup {
  display: flex;
  gap: 20px;
  align-items: center;
  margin-bottom: 18px;
  flex-wrap: nowrap;
}

#taskTypeGroup label {
  white-space: nowrap;
  font-size: 13px;
  cursor: pointer;
  display: flex;
  align-items: center;
  color: #ccffcc;
}

/* --- –ù–æ–≤—ã–π —Å—Ç–∏–ª—å –≥–ª–∞–≤–Ω—ã—Ö —Ä–∞–¥–∏–æ–∫–Ω–æ–ø–æ–∫ --- */
#taskTypeGroup input[type="radio"] {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  width: 18px;
  height: 18px;
  border: 2px solid #d8ffd8;
  border-radius: 50%;
  margin-right: 6px;
  position: relative;
  cursor: pointer;
  vertical-align: middle;
  background-color: rgba(0,0,0,0.45);
  transition: all 0.2s ease;
}

#taskTypeGroup input[type="radio"]:checked::before {
  content: '';
  position: absolute;
  top: 3px;
  left: 3px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: #00ff80;
}

#taskTypeGroup input[type="radio"]:hover {
  box-shadow: 0 0 6px #00ff80;
}

/* –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –±–ª–æ–∫–∏ —Ä–∞–¥–∏–æ–∫–Ω–æ–ø–æ–∫ –∏ —á–µ–∫–±–æ–∫—Å–æ–≤ */
#taskSettings label,
#habitSettings label,
#meetingSettings label {
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 13px;
  color: #ccffcc;
}

#taskSettings input[type="radio"],
#taskSettings input[type="checkbox"],
#habitSettings input[type="radio"],
#habitSettings input[type="checkbox"],
#meetingSettings input[type="radio"],
#meetingSettings input[type="checkbox"] {
  accent-color: #00ff80;
}

/* –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ —Ä–∞–¥–∏–æ–∫–Ω–æ–ø–æ–∫ –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è */
#durationGroup {
  display: flex;
  flex-wrap: nowrap;   /* –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ */
  gap: 14px;
  margin-top: 6px;
  margin-bottom: 14px;
}


/* –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –¥–Ω—è –¥–ª—è –ø—Ä–∏–≤—ã—á–∫–∏ –∏ –ø–ª–∞–Ω–∞ */
#dayTimeGroup {
  margin-bottom: 14px;
}

#dayTimeGroup label {
  display: inline-flex;
  gap: 5px;
  font-size: 13px;
}

/* –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –¥–Ω–∏ –Ω–µ–¥–µ–ª–∏ */
#daysGroup,
#meetingDaysGroup {
  margin-bottom: 14px;
}

#daysGroup label,
#meetingDaysGroup label {
  display: inline-flex;
  gap: 5px;
  font-size: 13px;
}


/* –ö–Ω–æ–ø–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –æ—Ç–º–µ–Ω—ã */
#addTaskMenu button {
  padding: 6px 12px;
  margin-right: 8px;
  border-radius: 8px;
  border: none;
  background: rgba(0,100,0,0.6);
  color: #d8ffd8;
  cursor: pointer;
  font-size: 13px;
  transition: background 0.2s;
}

#addTaskMenu button:hover {
  background: rgba(0,150,0,0.8);
}

#meetingTimeGroup {
  display: flex;
  flex-direction: column;
  align-items: center;   /* —Ü–µ–Ω—Ç—Ä –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ */
  gap: 12px;
}

#meetingTimeGroup input[type="date"],
#meetingTimeGroup input[type="time"] {
  font-size: 18px;        /* √ó2 –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ */
  padding: 10px 14px;
  min-width: 220px;
  text-align: center;

  background: transparent;
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 6px;
  color: #ccffcc;
}

/* ===== –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ –∑–∞–¥–∞—á ===== */


  

#nodeTasksWrapper {
  position: relative;
  width: 220px;          /* ‚Üê –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û */
  flex-shrink: 0;        /* ‚Üê –ó–ê–ü–†–ï–©–ê–ï–ú –°–ñ–ê–¢–ò–ï */
  display: flex;
  flex-direction: column;
}

  #nodeTasksWrapper {
  max-height: calc(5 * 56px + 20px); /* 6 –∑–∞–¥–∞—á + —Å—Ç—Ä–µ–ª–∫–∞ */
}
  
  

/* –û—Å–Ω–æ–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏ (–ø–µ—Ä–≤—ã–µ 6) */
#nodeTasksMain {
  display: flex;
  flex-direction: column;
  max-height: calc(5 * 56px);
  overflow: hidden;
  min-width: 200px;
  padding-bottom: 6px;
  flex-shrink: 0;
}

/* –ù–µ–±–æ–ª—å—à–æ–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É */
#nodeTasksMain::after {
  content: '';
  display: block;
  height: 4px;
}

/* –ö–Ω–æ–ø–∫–∞ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è */
#tasksToggle {
  position: absolute;
  top: 1%;
  right: -18px;          /* –≤—ã–Ω–æ—Å –≤–ø—Ä–∞–≤–æ */
  transform: translateY(-50%);

  cursor: pointer;
  user-select: none;
  opacity: 0.6;

  font-size: 14px;
}

#tasksToggle:hover {
  opacity: 1;
}


#nodeTasksExtra {
  position: absolute;
  top: -137px;                         /* ‚Üê —Å—Ç–∞—Ä—Ç —Å —Å–∞–º–æ–≥–æ –≤–µ—Ä—Ö–∞ */
  left: calc(100% + 24px);        /* –±–æ–ª—å—à–µ –≤–æ–∑–¥—É—Ö–∞ */

  width: 260px;
  height: calc(5 * 56px + 20px);  /* –¢–û–ß–ù–û –∫–∞–∫ —É –ª–µ–≤–æ–π —á–∞—Å—Ç–∏ */
  overflow-y: auto;

  display: none;

  background: rgba(15, 35, 20, 0.96);
  border: 1px solid rgba(120, 255, 160, 0.25);

  /* —É–±–∏—Ä–∞–µ–º —Å–∫—Ä—É–≥–ª–µ–Ω–∏–µ —Å–ª–µ–≤–∞ */
  border-radius: 0 12px 12px 0;

  padding: 10px 12px;

  box-shadow:
    0 8px 24px rgba(0,0,0,0.55),
    inset 0 0 0 1px rgba(255,255,255,0.03);
}


  #nodeTasksExtra::-webkit-scrollbar {
  width: 8px;
}

#nodeTasksExtra::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.05);
  border-radius: 4px;
}

#nodeTasksExtra::-webkit-scrollbar-thumb {
  background: rgba(120, 255, 160, 0.35);
  border-radius: 4px;
}

#nodeTasksExtra::-webkit-scrollbar-thumb:hover {
  background: rgba(120, 255, 160, 0.6);
}


.task-title {
  width: 150px;              /* —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞ */
  height: 22px;              /* ‚Üê –í–ê–ñ–ù–û */
  line-height: 22px;         /* ‚Üê –í–ê–ñ–ù–û */

  overflow: hidden;
  white-space: nowrap;
  position: relative;

  transform: translateZ(0);  /* —Ñ–∏–∫—Å–∏—Ä—É–µ–º —Å–ª–æ–π */
}

.task-title span {
  display: inline-block;
  white-space: nowrap;

  line-height: 22px;         /* ‚Üê —Å–æ–≤–ø–∞–¥–∞–µ—Ç */
  vertical-align: top;       /* ‚Üê –ö–õ–Æ–ß–ï–í–û */

  will-change: transform;
  transform: translate3d(0,0,0);
}

#taskNodeList {
  margin-bottom: 14px;
}

.node-item {
  padding: 6px 10px;
  margin-bottom: 4px;
  border-radius: 8px;
  background: rgba(0,30,0,0.25);
  cursor: pointer;
  user-select: none;
}

.node-item:hover {
  background: rgba(0,50,0,0.35);
}

.node-item.editing {
  background: rgba(0,0,0,0.4);
}

#taskNode {
  display: none;
}

#taskNodeDropdown {
  position: relative;
  margin-bottom: 14px;
}

#taskNodeSelected {
  padding: 8px 12px;
  border-radius: 8px;
  background: rgba(0,30,0,0.35);
  cursor: pointer;
  user-select: none;
  border: 1px solid rgba(180,255,180,0.25);
}

#taskNodeSelected:hover {
  background: rgba(0,50,0,0.45);
}

#taskNodeList {
  position: absolute;
  top: calc(100% + 6px);
  left: 0;
  right: 0;
  z-index: 10;

  display: none;
  max-height: 220px;
  overflow-y: auto;

  background: rgba(10,30,20,0.95);
  border-radius: 10px;
  padding: 6px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}

#taskNodeSelected {
  position: relative;
  overflow: hidden;
}

.longpress-progress {
  position: absolute;
  left: 0;
  bottom: 0;
  height: 2px;
  width: 0%;
  background: rgba(120, 255, 120, 0.9);
  transition: width linear;
  pointer-events: none;
}
  
  
#taskHistoryPanel {
  position: fixed;
  right: 0px;
  top: 50%;
  transform: translateY(-50%);
  width: 320px;
  height: 66vh;

  border-radius: 12px;
  overflow-y: auto;

  transition: right 0.25s ease, background 0.3s ease;



  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);

  border-left: 2px solid rgba(180,255,180,0.15);
  border-radius: 18px 0 0 18px;

  box-shadow:
    0 0 12px rgba(120,255,160,0.12),
    inset 0 0 6px rgba(180,255,180,0.05);

  color: #ccffcc;
  font-family: 'Exo 2', sans-serif;
  font-size: 12px;

  display: flex;
  flex-direction: column;

  z-index: 50;
  transition: right 0.25s ease;
}
  
 /* ===== –ó–∞–≥–æ–ª–æ–≤–æ–∫ ===== */
#taskHistoryTitle {
  font-size: 20px;
  font-weight: 800;
  padding: 14px 16px;
  letter-spacing: 0.5px;
}

/* ===== –°–ø–∏—Å–æ–∫ ===== */
#taskHistoryList {
  flex: 1;
  overflow-y: auto;
  padding: 14px 16px;
}

.task-history-item {
  margin-bottom: 10px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.task-history-time {
  font-size: 11px;
  opacity: 0.55;
}

.task-history-task {
  font-size: 13px;
}

.task-history-node {
  font-size: 11px;
  opacity: 0.7;
}

/* ===== Canvas ===== */
canvas {
  pointer-events: none;
}

/* ===== –ö–Ω–æ–ø–∫–∏ –ø–∞–Ω–µ–ª–∏ (–æ–±—â–∏–π —Å—Ç–∏–ª—å) ===== */
.panel-action-button {
  margin: 12px;
  padding: 8px 10px;

  background: rgba(255,255,255,0.08);
  color: inherit;

  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 8px;

  font-size: 12px;
  cursor: pointer;

  transition: background 0.2s ease;
}

.panel-action-button:hover {
  background: rgba(255,255,255,0.16);
}

/* ===== –ü–∞–Ω–µ–ª—å ===== */
#taskHistoryPanel {
  color: #ccffcc;
  display: flex;
  flex-direction: column;
}

/* ===== –ó–ï–õ–Å–ù–ê–Ø –¢–ï–ú–ê ===== */
#taskHistoryPanel.theme-green {
  background: linear-gradient(
    135deg,
    rgba(0,30,0,0.7),
    rgba(0,50,20,0.75),
    rgba(10,60,10,0.7)
  );
  color: #ccffcc;
}

/* ===== –ñ–Å–õ–¢–ê–Ø –¢–ï–ú–ê ===== */
#taskHistoryPanel.theme-yellow {
  background: linear-gradient(
    135deg,
    rgba(60,40,0,0.7),
    rgba(90,70,10,0.75),
    rgba(120,90,20,0.7)
  );
  color: #fff4cc;
}

/* ===== –§–ò–û–õ–ï–¢–û–í–ê–Ø –¢–ï–ú–ê ===== */
#taskHistoryPanel.theme-purple {
  background: linear-gradient(
    135deg,
    rgba(40,0,60,0.7),
    rgba(70,20,100,0.75),
    rgba(90,40,130,0.7)
  );
  color: #f0e6ff;
}

/* ===== –°–ò–ù–Ø–Ø –¢–ï–ú–ê ===== */
#taskHistoryPanel.theme-blue {
  background: linear-gradient(
    135deg,
    rgba(0,20,60,0.7),
    rgba(20,50,100,0.75),
    rgba(30,80,130,0.7)
  );
  color: #e6f0ff;
}

/* ===== –°–ï–†–ê–Ø –¢–ï–ú–ê ===== */
#taskHistoryPanel.theme-gray {
  background: linear-gradient(
    135deg,
    rgba(40,40,40,0.7),
    rgba(70,70,70,0.75),
    rgba(90,90,90,0.7)
  );
  color: #f0f0f0;
}

/* ===== –ß–Å–†–ù–ê–Ø –¢–ï–ú–ê ===== */
#taskHistoryPanel.theme-black {
  background: linear-gradient(
    135deg,
    rgba(0,0,0,0.75),
    rgba(20,20,20,0.85),
    rgba(40,40,40,0.75)
  );
  color: #eaeaea;
}

.panel-button-row {
  display: flex;
  gap: 10px;

  padding: 0 12px 8px;   /* üëà –º–µ–Ω—å—à–µ —Å–Ω–∏–∑—É */
  margin-top: 4px;      /* üëà –±–ª–∏–∂–µ –∫ –∫–Ω–æ–ø–∫–µ –≤—ã—à–µ */
}

.panel-button-row .panel-action-button {
  flex: 1;
  margin: 0;
}


.panel-button-row .panel-action-button {
  flex: 1;
  margin: 0; /* —É–±–∏—Ä–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π margin –∫–Ω–æ–ø–æ–∫ */
}

  
#checkpoint2,
#checkpointInput2,
#checkpoint3,
#checkpointInput3 {
  display: none;
}

  
  
  
  
#nodeLabels {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 20; /* –Ω–∏–∂–µ –º–µ–Ω—é, –≤—ã—à–µ canvas */
  display: none;
}

.node-label {
  position: absolute;
  padding: 6px 8px;
  border-radius: 6px;

  background: rgba(0,0,0,0.55);
  color: #fff;

  font-size: 11px;
  line-height: 1.3;
  white-space: nowrap;

  will-change: transform;
}

  
  
  
#taskHistoryTabs {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;

  padding: 8px 12px 10px;
  margin-bottom: 6px;

  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.task-history-tab {
  padding: 4px 10px;
  border-radius: 999px; /* –∞–∫–∫—É—Ä–∞—Ç–Ω—ã–µ ¬´–ø–∏–ª—é–ª–∏¬ª */

  font-size: 11px;
  font-weight: 500;
  letter-spacing: 0.2px;

  cursor: pointer;
  user-select: none;

  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.65);

  transition:
    background 0.15s ease,
    color 0.15s ease,
    box-shadow 0.15s ease;
}

.task-history-tab:hover {
  background: rgba(255,255,255,0.12);
  color: rgba(255,255,255,0.85);
}

.task-history-tab.active {
  background: rgba(255,255,255,0.22);
  color: #ffffff;

  box-shadow:
    0 0 0 1px rgba(255,255,255,0.18),
    inset 0 0 6px rgba(255,255,255,0.12);
}

/* ===== –í–∫–ª–∞–¥–∫–∞ "–í—Å–µ" ===== */
.task-history-tab-all {
  width: 100%;
  justify-content: center;

  text-align: center;
  font-weight: 600;
  letter-spacing: 0.4px;

  margin-bottom: 6px;
}

  
/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤–∫–ª–∞–¥–æ–∫ —É–∑–ª–æ–≤ ‚Äî –°–ö–†–´–¢ –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ */
#taskHistoryNodesTabs {
  display: none;
  margin-top: 6px;

  flex-wrap: wrap;
  gap: 6px;
}

/* –ü–û–ö–ê–ó–´–í–ê–ï–ú –¢–û–õ–¨–ö–û –ö–û–ì–î–ê –†–ê–°–ö–†–´–¢–û */
#taskHistoryTabs.expanded #taskHistoryNodesTabs {
  display: flex;
}

  

  
.task-history-tab-all::after {
  content: ' ‚ñ∂';
  font-size: 10px;
  opacity: 0.6;
  margin-left: 6px;
}

#taskHistoryTabs.expanded .task-history-tab-all::after {
  content: ' ‚ñº';
}

  
  
  
</style>
</head>
<body>
  
  
<body>

  <div id="nodeLabels"></div>

<input id="scaleSlider" type="range" min="0.5" max="3" step="0.01" value="1">




<div id="addTaskMenu" style="display:none; position:absolute; width:480px;">
  <input type="text" id="taskName" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏"><br>

  <div id="taskTypeGroup">
    <label><input type="radio" name="taskType" value="–∑–∞–¥–∞—á–∞" checked onchange="showTaskSettings()"> –ó–∞–¥–∞—á–∞</label>
    <label><input type="radio" name="taskType" value="–ø—Ä–∏–≤—ã—á–∫–∞" onchange="showTaskSettings()"> –ü—Ä–∏–≤—ã—á–∫–∞</label>
    <label><input type="radio" name="taskType" value="–≤—Å—Ç—Ä–µ—á–∞" onchange="showTaskSettings()"> –í—Å—Ç—Ä–µ—á–∏</label>
    <label><input type="radio" name="taskType" value="–ø–ª–∞–Ω" onchange="showTaskSettings()"> –ü–ª–∞–Ω/–ü—Ä–æ–µ–∫—Ç</label>
  </div>

  <div id="taskSettings">
    <div id="effortGroup">
      <label><input type="radio" name="effort" value="—Ç—Ä–µ–±—É–µ—Ç —É—Å–∏–ª–∏–π" checked> –ù—É–∂–Ω–æ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è</label>
      <label><input type="radio" name="effort" value="–Ω–µ —Ç—Ä–µ–±—É–µ—Ç —É—Å–∏–ª–∏–π"> –°–¥–µ–ª–∞—é –Ω–∞ –∞–≤—Ç–æ–º—Ç–µ</label>
    </div>

    <div id="timeGroup">
      <label><input type="radio" name="time" value="–Ω—É–∂–Ω–æ –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏" checked> –≠—Ç–æ –Ω–∞–¥–æ–ª–≥–æ</label>
      <label><input type="radio" name="time" value="–Ω–µ –Ω—É–∂–Ω–æ –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏"> –í—Ä–µ–º–µ–Ω–∏ –Ω–µ –æ—Ç–Ω–∏–º–µ—Ç</label>
    </div>
  </div>

  <div id="habitSettings" style="display:none;">
    <div id="dayTimeGroup">
      <label><input type="radio" name="dayTime" value="—É—Ç—Ä–æ" checked> –£—Ç—Ä–æ</label>
      <label><input type="radio" name="dayTime" value="–¥–µ–Ω—å"> –î–µ–Ω—å</label>
      <label><input type="radio" name="dayTime" value="–≤–µ—á–µ—Ä"> –í–µ—á–µ—Ä</label>
    </div>

    <div id="daysGroup">
      <label><input type="checkbox" name="days" value="–ø–Ω"> –ü–Ω</label>
      <label><input type="checkbox" name="days" value="–≤—Ç"> –í—Ç</label>
      <label><input type="checkbox" name="days" value="—Å—Ä"> –°—Ä</label>
      <label><input type="checkbox" name="days" value="—á—Ç"> –ß—Ç</label>
      <label><input type="checkbox" name="days" value="–ø—Ç"> –ü—Ç</label>
      <label><input type="checkbox" name="days" value="—Å–±"> –°–±</label>
      <label><input type="checkbox" name="days" value="–≤—Å"> –í—Å</label>
    </div>

    <div id="durationGroup">
      <label><input type="radio" name="duration" value="15 –º–∏–Ω—É—Ç" checked> 15 –º–∏–Ω</label>
      <label><input type="radio" name="duration" value="30 –º–∏–Ω—É—Ç"> 30 –º–∏–Ω</label>
      <label><input type="radio" name="duration" value="1 —á–∞—Å"> 1 —á–∞—Å</label>
      <label><input type="radio" name="duration" value="2 —á–∞—Å–∞"> 2 —á–∞—Å–∞</label>
      <label><input type="radio" name="duration" value="5 —á–∞—Å–æ–≤"> 5 —á–∞—Å–æ–≤</label>
    </div>
  </div>

  <div id="meetingSettings" style="display:none;">

    <div id="meetingTimeGroup">
      <input type="date" id="meetingDate">
      <input type="time" id="meetingTime">
      <textarea id="taskComment"></textarea>
    </div>
  </div>

<div id="taskNodeDropdown">
  <div id="taskNodeSelected">–í—ã–±–µ—Ä–∏—Ç–µ —É–∑–µ–ª</div>
  <div id="taskNodeList"></div>
</div>


  <button onclick="saveTask()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
  <button onclick="closeAddTaskMenu()">–û—Ç–º–µ–Ω–∞</button>
</div>

<!-- –ú–µ–Ω—é —É–∑–ª–∞ -->
<div id="nodeMenu">

  <input id="nodeNameInput" type="text" placeholder="Node name">

  <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —É–∑–ª–∞ -->
  <div id="nodeContent">

    <!-- –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: —á–µ–∫–ø–æ–∏–Ω—Ç—ã -->
    <div id="nodeCheckpoints">
      <div class="checkpointRow">
        <input type="checkbox" id="checkpoint1">
        <input type="text" id="checkpointInput1" placeholder="Operation 1">
      </div>

      <div class="checkpointRow">
        <input type="checkbox" id="checkpoint2">
        <input type="text" id="checkpointInput2" placeholder="Operation 2">
      </div>
      
      <div class="checkpointRow">
        <input type="checkbox" id="checkpoint3">
        <input type="text" id="checkpointInput3" placeholder="Operation 3">
      </div>
    </div>

    <!-- –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –∑–∞–¥–∞—á–∏ -->
    <div id="nodeTasksWrapper">

  <!-- –û—Å–Ω–æ–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏ (–¥–æ 6) -->
  <div id="nodeTasksMain"></div>

  <!-- –ö–Ω–æ–ø–∫–∞ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è -->
  <div id="tasksToggle">
    ‚ñ∂
  </div>

  <!-- –°–∫—Ä—ã—Ç—ã–µ –∑–∞–¥–∞—á–∏ -->
  <div id="nodeTasksExtra"></div>

</div>


  </div>
</div>






<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
  
const TASK_HISTORY_KEY = 'taskHistory';
  
  
let activeHistoryNode = 'ALL'; // üëà –í–û–¢ –≠–¢–ê –°–¢–†–û–ö–ê  

  
  
  

// ===== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã, –∫–∞–º–µ—Ä—ã, —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);
const camera = new THREE.PerspectiveCamera(
    75,                       // —É–≥–æ–ª –æ–±–∑–æ—Ä–∞
    window.innerWidth / window.innerHeight,
    0.05,                     // –±–ª–∏–∂–Ω—è—è –ø–ª–æ—Å–∫–æ—Å—Ç—å (–º–µ–Ω—å—à–µ, —á—Ç–æ–±—ã –ª–∏–Ω–∏–∏ –Ω–µ –∏—Å—á–µ–∑–∞–ª–∏ –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏)
    2000                      // –¥–∞–ª—å–Ω—è—è –ø–ª–æ—Å–∫–æ—Å—Ç—å (—á—Ç–æ–±—ã –ª–∏–Ω–∏–∏ –≤–∏–¥–Ω—ã –±—ã–ª–∏ –Ω–∞ –¥–∞–ª—å–Ω–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏)
);
camera.position.z = 100;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===== –°–≤–µ—Ç =====
scene.add(new THREE.AmbientLight(0x444444));
const pLight = new THREE.PointLight(0xffffff,1);
pLight.position.set(50,50,50);
scene.add(pLight);

// ===== CubeTexture =====
const loader = new THREE.CubeTextureLoader();
const urls = [
  'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
  'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
];
const cubeTexture = loader.load(urls);
scene.environment = cubeTexture;

// ===== –ì—Ä—É–ø–ø—ã –º–æ–¥–µ–ª–∏ =====
const modelGroup = new THREE.Group();
scene.add(modelGroup);
const graphGroup = new THREE.Group();
modelGroup.add(graphGroup);

// ===== –°—Ñ–µ—Ä–∞ =====
const sphereMat = new THREE.MeshPhysicalMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.05,
    roughness: 0.1,
    metalness: 0.1,
    side: THREE.BackSide
});
const sphereGeo = new THREE.SphereGeometry(1,64,64);
const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
modelGroup.add(sphereMesh);

const sphereLight = new THREE.PointLight(0x00ffff,0.2,500);
modelGroup.add(sphereLight);

// ===== –ß–∞—Å—Ç–∏—Ü—ã =====
const particleCount = 150;
const particles = [];
const particlePositions = new Float32Array(particleCount * 3);
const particleColors = new Float32Array(particleCount * 3);
const particleOpacities = new Float32Array(particleCount);

for(let i=0;i<particleCount;i++){
    const u = Math.random();
    const v = Math.random();
    const theta = u * 2 * Math.PI;
    const phi = Math.acos(2*v - 1);
    const r = Math.cbrt(Math.random());
    const speed = (0.001 + Math.random()*0.002)/10;

    particles.push({
        theta, phi, r, speed,
        opacityPhase: Math.random()*Math.PI*2,
        opacitySpeed: 0.00005 + Math.random()*0.0001,
        opacityAmplitude: 0.05 + Math.random()*0.15
    });

    // –ù–∞—á–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
    particlePositions[i*3] = r*Math.sin(phi)*Math.cos(theta);
    particlePositions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
    particlePositions[i*3+2] = r*Math.cos(phi);

    // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç
    const col = new THREE.Color(Math.random(), Math.random(), Math.random());
    particleColors[i*3] = col.r;
    particleColors[i*3+1] = col.g;
    particleColors[i*3+2] = col.b;

    particleOpacities[i] = 0.05;
}

const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions,3));
particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors,3));

const particleMat = new THREE.PointsMaterial({
    size: 0.03,
    transparent: true,
    vertexColors: true,
    opacity: 0.5
});

const particlePoints = new THREE.Points(particleGeo, particleMat);
modelGroup.add(particlePoints);

let taskHistoryVisible = false;

  function toggleTaskHistoryPanel() {
  const panel = document.getElementById('taskHistoryPanel');
  if (!panel) return;

  taskHistoryVisible = !taskHistoryVisible;
    
  if (taskHistoryVisible) {
    loadTaskHistory(); // üëà –í–û–¢ –≠–¢–ê –°–¢–†–û–ö–ê
  }

  panel.style.right = taskHistoryVisible ? '0' : '-320px';
}

  
  
// ===== –£–∑–ª—ã =====
const nodeGeo = new THREE.SphereGeometry(1,32,32);
function createNode(x,y,status,link,name='Node', id){
    const NODE_RADIUS = 1;
    const colorMap = {Green:0x00cc44, Yellow:0xffcc00, Red:0xcc2222};
    const mat = new THREE.MeshPhysicalMaterial({
        color: colorMap[status],
        transparent:true,
        transmission:0.8,
        roughness:0.05,
        metalness:0.1,
        ior:1.5,
        clearcoat:0.4,
        clearcoatRoughness:0.1,
        envMap:cubeTexture,
        envMapIntensity:1.0
    });
  
    const mesh = new THREE.Mesh(nodeGeo, mat);
    mesh.position.set(x,y,0);
    mesh.renderOrder = 12;     // ‚Üê –ö–õ–Æ–ß
    graphGroup.add(mesh);

    const glow = new THREE.PointLight(colorMap[status],0.05,10);
    glow.position.copy(mesh.position);
    graphGroup.add(glow);

// --- HALO –∫–∞–∫ –¥–æ—á–µ—Ä–Ω–∏–π –æ–±—ä–µ–∫—Ç (—Å—Ç–µ–∫–ª—è–Ω–Ω—ã–π, –∫–∞–∫ –±–æ–ª—å—à–∞—è —Å—Ñ–µ—Ä–∞) ---
const haloGeo = new THREE.SphereGeometry(1.2, 32, 32);

const haloMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  transparent: true,
  opacity: 0.05,
  roughness: 0.1,
  metalness: 0.1,
  transmission: 0.3,
  ior: 1.5,
  clearcoat: 0.6,
  clearcoatRoughness: 0.1,
  envMap: cubeTexture,
  envMapIntensity: 1.0,
  side: THREE.DoubleSide
});

// üîë –ö–õ–Æ–ß–ï–í–´–ï –§–õ–ê–ì–ò (–¥–æ —Å–æ–∑–¥–∞–Ω–∏—è mesh)
haloMat.depthWrite = false;
haloMat.depthTest  = false;

// ‚úÖ –¢–û–õ–¨–ö–û –¢–ï–ü–ï–†–¨ —Å–æ–∑–¥–∞—ë–º mesh
const haloMesh = new THREE.Mesh(haloGeo, haloMat);

// üîë –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ mesh
haloMesh.userData.isHalo = true;
haloMesh.renderOrder = 10;
mesh.renderOrder = 12;

// –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ —É–∑–ª—É
mesh.add(haloMesh);
haloMesh.position.set(0, 0, 0);

    const driftPhaseX = Math.random()*Math.PI*2;
    const driftPhaseY = Math.random()*Math.PI*2;
    const driftSpeedX = (0.001 + Math.random()*0.001)/6;
    const driftSpeedY = (0.001 + Math.random()*0.001)/6;
    const driftRadiusX = 0.02 + Math.random()*0.02;
    const driftRadiusY = 0.02 + Math.random()*0.02;

    return {
    id: id,
    tasks: [],
    isHighlighted: false, // ‚Üê –í–ê–ñ–ù–û
    mesh,
    radius: NODE_RADIUS,
    glow,
    halo: haloMesh,
    status,
    gravityForce: 1,
    connectedLines: [],
    velocity: new THREE.Vector3(0,0,0),
    link,
    name,
    driftPhaseX,
    driftPhaseY,
    driftSpeedX,
    driftSpeedY,
    driftRadiusX,
    driftRadiusY,
    menuActive: false,
    lastClickTime: 0,  // <-- –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–≤–æ–π–Ω–æ–≥–æ –∫–ª–∏–∫–∞
    checkpoints: [
        {checked:false, text:''},
        {checked:false, text:''},
        {checked:false, text:''}
    ]
};

}


// ===== –°–æ–∑–¥–∞–µ–º —É–∑–ª—ã =====
const nodes=[];
for(let i=0;i<15;i++){
    const x=(Math.random()-0.5)*40;
    const y=(Math.random()-0.5)*40;
    const status=['Green','Yellow','Red'][Math.floor(Math.random()*3)];
    const link = `obsidian://open?vault=PALADIN&file=StructalGraphOperations/NodeOperations${i+1}`;
    nodes.push(createNode(x,y,status,link, `Node${i+1}`, `node${i+1}`));
}

buildHistoryTabs();

  
  
// ===== –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–æ–≤ —É–∑–ª–æ–≤ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ =====
setInterval(() => {
  nodes.forEach(node => {
    updateNodeStatusByTasks(node);
    applyNodeColor(node);
  });
}, 1000);
  

  
// ===== –õ–∏–Ω–∏–∏ =====
function createCable(a,b,segments=10){
    const pts=[];
    for(let i=0;i<=segments;i++){
        const t=i/segments;
        pts.push(new THREE.Vector3().lerpVectors(a.mesh.position,b.mesh.position,t));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    
    // ===== –°–∫—Ä—ã–≤–∞–µ–º –ª–∏–Ω–∏—é, –µ—Å–ª–∏ –æ–Ω–∞ –ø—Ä–æ—Ö–æ–¥–∏—Ç —á–µ—Ä–µ–∑ —É–∑–µ–ª =====
const camPos = camera.position;
let nearNode = false;

for (let i = 0; i < pts.length; i++) {
    const p = pts[i];

    // —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –ª–∏–Ω–∏–∏ –¥–æ –∫–∞–º–µ—Ä—ã
    const dCam = p.distanceTo(camPos);

    // —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —É–∑–ª–æ–≤
    const dA = p.distanceTo(a.mesh.position);
    const dB = p.distanceTo(b.mesh.position);

    if (
        (dA < a.mesh.scale.x * 1.1 && dCam > a.mesh.position.distanceTo(camPos)) ||
        (dB < b.mesh.scale.x * 1.1 && dCam > b.mesh.position.distanceTo(camPos))
    ) {
        nearNode = true;
        break;
    }
}

  
  
    const mat = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.1,
    depthTest: false,      // –ø—Ä–æ–≤–µ—Ä–∫–∞ –≥–ª—É–±–∏–Ω—ã –≤—ã–∫–ª—é—á–µ–Ω–∞
    depthWrite: false     // –ª–∏–Ω–∏–∏ –Ω–µ "–∑–∞–∫—Ä—ã–≤–∞—é—Ç" –¥—Ä—É–≥–∏–µ –æ–±—ä–µ–∫—Ç—ã, –≤—Å–µ–≥–¥–∞ –≤–∏–¥–Ω—ã
});

    const line = new THREE.Line(geo, mat);
    line.renderOrder = 1;          // ‚Üê –í–ê–ñ–ù–û
    graphGroup.add(line);
    a.connectedLines.push(line);
    b.connectedLines.push(line);
    line.userData = {a,b,segments};
    return line;
}
nodes.forEach((n,i)=>{for(let j=i+1;j<nodes.length;j++) createCable(n,nodes[j]);});
  
  
  
function updateNodeLabels() {
  if (!labelsEnabled) return;

  const w = window.innerWidth;
  const h = window.innerHeight;

  nodes.forEach(node => {
    if (!node.label) return;

    const total = node.tasks.length;
    const done = node.tasks.filter(t => t.completed).length;

    node.label.el.innerHTML = `
      <b>${node.name}</b><br>
      ${done} / ${total}
    `;

    const p = node.mesh.position.clone();
    p.project(camera);

    const tx = (p.x * 0.5 + 0.5) * w + 18;
    const ty = (-p.y * 0.5 + 0.5) * h - 18;

    node.label.x += (tx - node.label.x) * 0.12;
    node.label.y += (ty - node.label.y) * 0.12;

    node.label.el.style.transform =
      `translate(${node.label.x}px, ${node.label.y}px)`;

    node.label.el.style.display = p.z < 1 ? 'block' : 'none';
  });
}
  


// ===== Hover =====
let hoveredNode = null;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
window.addEventListener('mousemove', e=>{
    mouse.x = (e.clientX/window.innerWidth)*2 -1;
    mouse.y = -(e.clientY/window.innerHeight)*2 +1;
    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh), false)
        .filter(i => !i.object.userData.isHalo);
    hoveredNode = intersects.length>0 ? nodes.find(n=>n.mesh===intersects[0].object) : null;
});

  
  
function addTaskHistory(taskName, nodeName) {
  // 1. –ë–µ—Ä—ë–º –∏—Å—Ç–æ—Ä–∏—é –∏–∑ localStorage
  const history = JSON.parse(
    localStorage.getItem(TASK_HISTORY_KEY) || '[]'
  );

  // 2. –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
  const now = new Date();
  const time = now.toLocaleTimeString([], {
    hour: '2-digit',
    minute: '2-digit'
  });

  // 3. –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å –≤ –Ω–∞—á–∞–ª–æ
  history.unshift({
    time: time,
    task: taskName,
    node: nodeName
  });

  // 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ
  localStorage.setItem(
    TASK_HISTORY_KEY,
    JSON.stringify(history)
  );
}


  
  
  
function updateNodeTasks(node) {
  const main = document.getElementById('nodeTasksMain');
  const extra = document.getElementById('nodeTasksExtra');

  if (!main || !extra) return;

  main.innerHTML = '';
  extra.innerHTML = '';

  node.tasks.forEach((task, index) => {

    // ===== –ß–µ–∫–±–æ–∫—Å =====
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = task.completed;
    checkbox.style.marginRight = '6px';

 checkbox.addEventListener('change', () => {

  const wasCompleted = task.completed;
  task.completed = checkbox.checked;

  // —É–¥–∞–ª—è–µ–º –∏–∑ —Å–ø–∏—Å–∫–∞
  const index = node.tasks.indexOf(task);
  if (index !== -1) {
    node.tasks.splice(index, 1);
  }

  // –µ—Å–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ ‚Üí –≤–Ω–∏–∑, –∏–Ω–∞—á–µ ‚Üí –≤–≤–µ—Ä—Ö
  if (task.completed && !wasCompleted) {
    addTaskHistory(task.name, node.name);
    loadTaskHistory(); 
    node.tasks.push(task);
  } else {
    node.tasks.unshift(task);
  }

  updateNodeStatusByTasks(node);
  applyNodeColor(node);

  saveNodesState();
  updateNodeTasks(node);
});



    // ===== –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–¥–∞—á–∏ =====
    const taskDiv = document.createElement('div');
    taskDiv.style.display = 'flex';
    taskDiv.style.flexDirection = 'column';
    taskDiv.style.marginBottom = '8px';
    taskDiv.style.minHeight = '34px';


    // ===== –°—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∞ =====
    const titleRow = document.createElement('div');
    titleRow.style.display = 'flex';
    titleRow.style.alignItems = 'flex-start';

    
    
    titleRow.style.justifyContent = 'space-between';
    titleRow.style.height = '22px';      // ‚Üê —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏
    titleRow.style.lineHeight = '22px';  // ‚Üê —Ñ–∏–∫—Å–∏—Ä—É–µ–º baseline



    const title = document.createElement('div');
    title.className = 'task-title';
    title.style.height = '22px';
    title.style.lineHeight = '22px';
    title.style.contain = 'layout paint';




const titleSpan = document.createElement('span');
titleSpan.textContent = task.name;

title.appendChild(titleSpan);
    
    let hoverTimer = null;
let animFrame = null;

title.addEventListener('mouseenter', () => {
  hoverTimer = setTimeout(() => {
    const containerWidth = title.clientWidth;
    const textWidth = titleSpan.scrollWidth;

    if (textWidth <= containerWidth) return;

    let start = null;
    const distance = textWidth - containerWidth + 10; // –∑–∞–ø–∞—Å
    const duration = 1500; // —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–æ–∫—Ä—É—Ç–∫–∏

    function animateScroll(timestamp) {
      if (!start) start = timestamp;
      const progress = (timestamp - start) / duration;

      const offset = Math.min(progress, 1) * distance;
      titleSpan.style.transform = `translate3d(-${offset}px, 0, 0)`;


      if (progress < 1) {
        animFrame = requestAnimationFrame(animateScroll);
      }
    }

    animFrame = requestAnimationFrame(animateScroll);
  }, 900); // ‚Üê –∑–∞–¥–µ—Ä–∂–∫–∞ 2 —Å–µ–∫—É–Ω–¥—ã
});

title.addEventListener('mouseleave', () => {
  clearTimeout(hoverTimer);
  hoverTimer = null;

  if (animFrame) {
    cancelAnimationFrame(animFrame);
    animFrame = null;
  }

  titleSpan.style.transform = 'translateX(0)';
});


    
    
    title.style.fontSize = '13px';
    title.style.color = '#ccffcc';

    if (task.completed) {
      title.style.textDecoration = 'line-through';
      title.style.opacity = '0.5';
    }

    // –õ–µ–≤–∞—è –≥—Ä—É–ø–ø–∞: —á–µ–∫–±–æ–∫—Å + –Ω–∞–∑–≤–∞–Ω–∏–µ
const leftGroup = document.createElement('div');
leftGroup.style.display = 'flex';
leftGroup.style.alignItems = 'center';

leftGroup.appendChild(checkbox);
leftGroup.appendChild(title);

// –ö–Ω–æ–ø–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è ‚úï
const deleteBtn = document.createElement('span');
deleteBtn.textContent = '‚úï';
deleteBtn.style.cursor = 'pointer';
deleteBtn.style.opacity = '0.15';
deleteBtn.style.marginLeft = '8px';
deleteBtn.style.fontSize = '12px';

deleteBtn.addEventListener('mouseenter', () => {
  deleteBtn.style.opacity = '0.45';
});
deleteBtn.addEventListener('mouseleave', () => {
  deleteBtn.style.opacity = '0.15';
});

let deleteTimer = null;

deleteBtn.addEventListener('mousedown', () => {
  // –∑–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä —É–¥–µ—Ä–∂–∞–Ω–∏—è
  deleteTimer = setTimeout(() => {
    // –º—è–≥–∫–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è
    taskDiv.style.opacity = '0';
    taskDiv.style.transform = 'translateX(10px)';
    taskDiv.style.height = '0';
    taskDiv.style.marginBottom = '0';

    // —É–¥–∞–ª—è–µ–º –∏–∑ –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
    setTimeout(() => {
      const index = node.tasks.indexOf(task);
      if (index !== -1) {
        node.tasks.splice(index, 1);
        saveNodesState();
        updateNodeTasks(node);
      }
    }, 250);

  }, 3000); // 3 —Å–µ–∫—É–Ω–¥—ã —É–¥–µ—Ä–∂–∞–Ω–∏—è
});

deleteBtn.addEventListener('mouseup', () => {
  clearTimeout(deleteTimer);
  deleteTimer = null;
});

deleteBtn.addEventListener('mouseleave', () => {
  clearTimeout(deleteTimer);
  deleteTimer = null;
});
    

// ===== –ò–ö–û–ù–ö–ê –°–°–´–õ–ö–ò üîó =====
const linkIcon = document.createElement('span');

linkIcon.textContent = 'üîó';
linkIcon.style.cursor = 'pointer';
linkIcon.style.marginLeft = '6px';
linkIcon.style.fontSize = '13px';
linkIcon.style.userSelect = 'none';
linkIcon.style.opacity = task.link ? '0.4' : '0.12';

linkIcon.addEventListener('mouseenter', () => {
  linkIcon.style.opacity = task.link ? '0.6' : '0.3';
});

linkIcon.addEventListener('mouseleave', () => {
  linkIcon.style.opacity = task.link ? '0.4' : '0.12';
});

let linkPressTimer = null;
let isEditingLink = false;
let longPressTriggered = false;

// ===== LONG PRESS =====
linkIcon.addEventListener('mousedown', e => {
  e.stopPropagation();
  if (isEditingLink) return;

  longPressTriggered = false;

  linkPressTimer = setTimeout(() => {
    longPressTriggered = true;
    startEditTaskLink();
  }, 1200);
});

linkIcon.addEventListener('mouseup', e => {
  e.stopPropagation();
  clearTimeout(linkPressTimer);
});

linkIcon.addEventListener('mouseleave', () => {
  clearTimeout(linkPressTimer);
  longPressTriggered = false;
});

// ===== CLICK =====
linkIcon.addEventListener('click', e => {
  e.stopPropagation();

  if (longPressTriggered) {
    longPressTriggered = false;
    return;
  }

  if (task.link) {
    window.open(task.link, '_blank');
  }
});

// ===== –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–ï –°–°–´–õ–ö–ò =====
function startEditTaskLink() {
  if (isEditingLink) return;
  isEditingLink = true;

  linkIcon.style.display = 'none';
  rightGroup.style.position = 'relative';


  const input = document.createElement('input');
  
  input.style.position = 'absolute';
input.style.right = '0';
input.style.top = '50%';
input.style.transform = 'translateY(-50%)';

input.style.width = '160px';
input.style.fontSize = '12px';
input.style.zIndex = '10';

  
  input.type = 'text';
  input.placeholder = 'obsidian://...';
  input.value = task.link || '';
  
  rightGroup.appendChild(input);


  
  input.focus();
  input.select();

  function finish(save) {
    if (save) {
      const value = input.value.trim();
      task.link = value || null;
    }

    saveNodesState();

    input.remove();
    linkIcon.style.display = '';
    linkIcon.style.opacity = task.link ? '0.4' : '0.12';

    isEditingLink = false;
  }

  input.addEventListener('blur', () => finish(true));

  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') input.blur();
    if (e.key === 'Escape') finish(false);
  });
}




// –§–ò–ù–ê–õ–¨–ù–ê–Ø –°–ë–û–†–ö–ê titleRow ‚¨á‚¨á‚¨á
const rightGroup = document.createElement('div');
rightGroup.style.display = 'flex';
rightGroup.style.alignItems = 'center';

rightGroup.appendChild(linkIcon);
rightGroup.appendChild(deleteBtn);

titleRow.appendChild(leftGroup);
titleRow.appendChild(rightGroup);


    taskDiv.appendChild(titleRow);

    // ===== –ú–µ—Ç–∞-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è (–≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É) =====
    const metaParts = [];

    if (task.date) metaParts.push(task.date);
    if (task.meetingTime) metaParts.push(task.meetingTime);
    if (task.difficulty) metaParts.push(task.difficulty);
    if (task.dayTime) metaParts.push(task.dayTime);
    if (task.days && task.days.length > 0) metaParts.push(task.days.join('¬∑'));
    if (task.duration) metaParts.push(task.duration);

    if (metaParts.length > 0) {
      const meta = document.createElement('div');
      meta.textContent = metaParts.join(' ¬∑ ');
      meta.style.fontSize = '11px';
      meta.style.opacity = '0.6';
      meta.style.marginLeft = '22px';
      taskDiv.appendChild(meta);
    }

    // ===== –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π (–æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π, –µ—Å–ª–∏ –Ω—É–∂–µ–Ω) =====
    if (task.comment) {
      const comment = document.createElement('div');
      comment.textContent = task.comment;
      comment.style.fontSize = '11px';
      comment.style.opacity = '0.5';
      comment.style.marginLeft = '22px';
      taskDiv.appendChild(comment);
    }

    // ===== –†–ê–ó–î–ï–õ–ï–ù–ò–ï: –ø–µ—Ä–≤—ã–µ 6 ‚Üí main, –æ—Å—Ç–∞–ª—å–Ω—ã–µ ‚Üí extra =====
    if (index < 6) {
      main.appendChild(taskDiv);
    } else {
      extra.appendChild(taskDiv);
    }

  });
}


  
// ===== UI –º–µ–Ω—é =====
const menuDiv = document.getElementById('nodeMenu');
const nodeNameInput = document.getElementById('nodeNameInput');

// –¢–µ–∫—É—â–∏–π —É–∑–µ–ª, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –æ—Ç–∫—Ä—ã—Ç–æ –º–µ–Ω—é
let currentMenuNode = null;

// ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π –º–µ–Ω—é –∏–∑ –¥–∞–Ω–Ω—ã—Ö —É–∑–ª–∞ =====
function updateMenuFields() {
    if (!currentMenuNode) return;

    nodeNameInput.value = currentMenuNode.name;

    for (let i = 0; i < 3; i++) {
        const checkbox = document.getElementById('checkpoint' + (i + 1));
        const input = document.getElementById('checkpointInput' + (i + 1));
        checkbox.checked = currentMenuNode.checkpoints[i].checked;
        input.value = currentMenuNode.checkpoints[i].text;
    }
}
  
  
  
let selectedTaskNodeId = null;
  

  

// ===== –°–æ–±—ã—Ç–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —á–µ–∫–ø–æ–∏–Ω—Ç–æ–≤ –∏ —Ç–µ–∫—Å—Ç–æ–≤ =====
for (let i = 0; i < 3; i++) {
    // –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å —á–µ—Ä–µ–∑ IIFE, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∑–∞–º—ã–∫–∞–Ω–∏—è
    ((index) => {
        const checkbox = document.getElementById('checkpoint' + (index + 1));
        const input = document.getElementById('checkpointInput' + (index + 1));

        checkbox.addEventListener('change', (e) => {
            if (currentMenuNode) {
                currentMenuNode.checkpoints[index].checked = e.target.checked;
                saveNodesState(); // <-- –¥–æ–±–∞–≤–ª—è–µ–º —Å—é–¥–∞
            }
        });

        input.addEventListener('input', (e) => {
            if (currentMenuNode) {
                currentMenuNode.checkpoints[index].text = e.target.value;
                saveNodesState(); // <-- –¥–æ–±–∞–≤–ª—è–µ–º —Å—é–¥–∞
            }
        });
    })(i);
}

// ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –º–µ–Ω—é =====
function updateMenuPosition(node, menuDiv) {
    const localOffset = new THREE.Vector3(0, 4, 0);
    const worldPos = node.mesh.getWorldPosition(new THREE.Vector3()).add(localOffset);
    const pos = worldPos.clone().project(camera);

    let targetX = (pos.x + 1) / 2 * window.innerWidth;
    let targetY = (-pos.y + 1) / 2 * window.innerHeight;

    let currentX = parseFloat(menuDiv.dataset.x) || targetX;
    let currentY = parseFloat(menuDiv.dataset.y) || targetY;
    const smooth = 0.15;
    currentX += (targetX - currentX) * smooth;
    currentY += (targetY - currentY) * smooth;



    menuDiv.style.left = currentX + 'px';
    menuDiv.style.top = currentY + 'px';

    menuDiv.dataset.x = currentX;
    menuDiv.dataset.y = currentY;
}

// ===== –û—Ç–∫—Ä—ã—Ç–∏–µ / –∑–∞–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é =====
window.addEventListener('mousedown', event => {
    if (event.button === 1) { // –∫–æ–ª–µ—Å–æ –º—ã—à–∏
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh), false)
            .filter(i => !i.object.userData.isHalo);

        if (intersects.length > 0) {
            const clickedNode = nodes.find(n => n.mesh === intersects[0].object);
          
          // ===== –î–í–û–ô–ù–û–ô –ö–õ–ò–ö –°–ö–ú ‚Üí HALO =====
const now = performance.now();
const DOUBLE_CLICK_DELAY = 350;

if (now - clickedNode.lastClickTime < DOUBLE_CLICK_DELAY) {
  // toggle halo
  clickedNode.isHighlighted = !clickedNode.isHighlighted;
  clickedNode.halo.visible = clickedNode.isHighlighted;

  // —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  saveNodesState();

  // ‚õîÔ∏è –í–ê–ñ–ù–û: —á—Ç–æ–±—ã –¥–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–ª –º–µ–Ω—é
  clickedNode.lastClickTime = 0;
  return;
}

clickedNode.lastClickTime = now;


            if (currentMenuNode === clickedNode) {
                // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é
                currentMenuNode.menuActive = false;
                currentMenuNode = null;
                menuDiv.style.opacity = '0';
                setTimeout(() => menuDiv.style.display = 'none', 250);
            } else {
    // ‚ùó –°–ë–†–ê–°–´–í–ê–ï–ú –ø—Ä–µ–¥—ã–¥—É—â–∏–π —É–∑–µ–ª
    if (currentMenuNode) {
        currentMenuNode.menuActive = false;
    }

    // –û—Ç–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é –Ω–∞ –Ω–æ–≤–æ–º —É–∑–ª–µ
    currentMenuNode = clickedNode;
    clickedNode.menuActive = true;
                menuDiv.style.display = 'block';
                menuDiv.style.opacity = '1';
                menuDiv.style.transform = 'scale(1)';
                menuDiv.classList.add('active');

                menuDiv.dataset.x = '';
                menuDiv.dataset.y = '';
                updateMenuFields(); // –∑–∞–ø–æ–ª–Ω—è–µ–º –ø–æ–ª—è –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —É–∑–ª–∞
                updateNodeTasks(currentMenuNode);
            }
        } else {
            // –ö–ª–∏–∫ –≤–Ω–µ —É–∑–ª–∞ ‚Äî –∑–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é
            if (currentMenuNode) currentMenuNode.menuActive = false;
            currentMenuNode = null;
            menuDiv.style.opacity = '0';
menuDiv.style.transform = 'scale(0.96)';
menuDiv.classList.remove('active');
setTimeout(() => menuDiv.style.display = 'none', 250);


        }
    }
});

// ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é –Ω–∞ –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä =====
function updateMenuPositionAndFields() {
    if (currentMenuNode) {
        updateMenuPosition(currentMenuNode, menuDiv);
        updateMenuFields();
    }
}

// ===== –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ —É–∑–ª–∞ =====
nodeNameInput.addEventListener('input', () => {
    if (currentMenuNode) {
        currentMenuNode.name = nodeNameInput.value;
    }
});


// ===== –°—á–µ—Ç –∫—Ä–∞—Å–Ω—ã—Ö —É–∑–ª–æ–≤ =====
function countRedNodes(){ return nodes.filter(n => n.status==='Red').length; }

// ===== –¶–µ–Ω—Ç—Ä –∏ –º–∞—Å—à—Ç–∞–± –≥—Ä–∞—Ñ–∞, —Å—Ñ–µ—Ä–∞ =====
let currentSphereRadius = 10;
let targetSphereRadius = 10;

function updateGraphAndSphere(time){
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    nodes.forEach(n=>{
        const p = n.mesh.position;
        if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
        if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
    });
    const centerX = (minX+maxX)/2;
    const centerY = (minY+maxY)/2;
    graphGroup.position.set(-centerX, -centerY, 0);
    const graphWidth = maxX-minX;
    const graphHeight = maxY-minY;
    const graphMax = Math.max(graphWidth, graphHeight);
    const scale = graphMax>0 ? 40/graphMax : 1;
    const baseSphereRadius = Math.max(graphWidth,graphHeight)/2 * 1.1 * scale;
    const redCount = countRedNodes();
    const redRatio = redCount/nodes.length;
    const redFactor = redRatio>0.5 ? 1 + redRatio : 1;
    targetSphereRadius = baseSphereRadius * redFactor;
    currentSphereRadius = THREE.MathUtils.lerp(currentSphereRadius, targetSphereRadius, 0.02);
    sphereMesh.scale.set(currentSphereRadius,currentSphereRadius,currentSphereRadius);
    sphereMesh.position.set(0,0,0);
    sphereLight.position.set(0,0,0);
// –£—Å–∏–ª–µ–Ω–∏–µ –Ω–∞ 10‚Äì20%
const intensity = (0.15 + 0.05 * Math.sin(time*0.005/3)) * 1.1;
sphereLight.intensity = intensity;
sphereMesh.material.opacity = (0.03 + 0.02 * Math.sin(time*0.005/3)) * 2.9;

    return currentSphereRadius;
}

// ===== –°–ø–∏—Ä–∞–ª–∏ =====
const spiralBezelGroup = new THREE.Group();
modelGroup.add(spiralBezelGroup);
const spiralLayers = 4;
const spiralLines = [];
for(let layer=0; layer<spiralLayers; layer++){
    const redCount = countRedNodes();
const redRatio = redCount / nodes.length; // 0..1

const spiralTurns = 3 + layer + Math.floor(redRatio * 5); // —á–µ–º –±–æ–ª—å—à–µ –∫—Ä–∞—Å–Ω—ã—Ö —É–∑–ª–æ–≤, —Ç–µ–º –±–æ–ª—å—à–µ –≤–∏—Ç–∫–æ–≤
const spiralSegments = 120 + Math.floor(redRatio * 60); // —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—é –ø—Ä–∏ —Ä–æ—Å—Ç–µ –∫—Ä–∞—Å–Ω—ã—Ö —É–∑–ª–æ–≤
const radiusOffset = 1 + layer*0.2 + redRatio * 0.5; // —Å–ø–∏—Ä–∞–ª—å ¬´—Ä–∞–∑–¥—É–≤–∞–µ—Ç—Å—è¬ª —Å —Ä–æ—Å—Ç–æ–º –∫—Ä–∞—Å–Ω—ã—Ö —É–∑–ª–æ–≤
  
    const rotationSpeed = 0.001 + layer*0.0015;
    for(let t=0; t<spiralTurns; t++){
        const points = [];
        for(let i=0;i<=spiralSegments;i++){
            const angle = (i/spiralSegments)*Math.PI*2 + t*Math.PI/spiralTurns;
            const z = (i/spiralSegments - 0.5) * 2;
            points.push(new THREE.Vector3(Math.cos(angle)*radiusOffset, Math.sin(angle)*radiusOffset, z));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(points);
      
        const mat = new THREE.LineBasicMaterial({
  color: 0x00ffff,
  transparent: true,
  opacity: 0.125,
  depthTest: false,     // ‚Üê –ö–õ–Æ–ß ‚Ññ1
  depthWrite: false
});

const line = new THREE.Line(geo, mat);
line.renderOrder = 2;   // ‚Üê –ö–õ–Æ–ß ‚Ññ2 (–≤—ã—à–µ –≥—Ä–∞—Ñ-–ª–∏–Ω–∏–π, –Ω–∏–∂–µ —É–∑–ª–æ–≤)
spiralBezelGroup.add(line);


        spiralLines.push({line, phase: Math.random()*Math.PI*2, rotationSpeed});
    }
}

// ===== –ê–Ω–∏–º–∞—Ü–∏—è =====
function animate(time=0){
    requestAnimationFrame(animate);

    nodes.forEach(n=>{

// –ü–ª–∞–≤–Ω–æ–µ –º–µ—Ä—Ü–∞–Ω–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —Å–≤–µ—á–µ–Ω–∏—è (emissive)
const pulse = 0.01 + 0.01 * Math.sin(time * 0.0005 + n.mesh.id); // –º–µ–¥–ª–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è
            
      
n.mesh.material.emissiveIntensity = 0.4 + 0.2 * Math.sin(time * 0.008 + n.mesh.id);

// –ú–æ–∂–Ω–æ —Å–ª–µ–≥–∫–∞ –º–µ–Ω—è—Ç—å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å—Ç–µ–∫–ª—è–Ω–Ω–æ–π –ª–∞–º–ø–æ—á–∫–∏
const baseOpacity = 0.7;
n.mesh.material.opacity = THREE.MathUtils.lerp(n.mesh.material.opacity, baseOpacity + 0.1 * Math.sin(time * 0.006 + n.mesh.id), 0.05);


    // --- –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞ ---
    const targetScale = (n.menuActive || n === hoveredNode) ? 1.2 : 1;
    n.mesh.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale), 0.1);

    // --- HALO ---
// --- –ê–Ω–∏–º–∞—Ü–∏—è HALO ---
const haloBaseScale = 1.001; // –±–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä HALO –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —É–∑–ª–∞
const haloActiveMultiplier = n.isHighlighted ? 1.3 : 1;
const haloTargetScale = n.mesh.scale.x * haloBaseScale * haloActiveMultiplier;

// –ü–ª–∞–≤–Ω–æ –∏–∑–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–± HALO
n.halo.scale.lerp(new THREE.Vector3(haloTargetScale, haloTargetScale, haloTargetScale), 0.08);

// –ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å HALO
const haloTargetOpacity = n.isHighlighted ? 0.15 : 0;

n.halo.material.opacity = THREE.MathUtils.lerp(
  n.halo.material.opacity,
  haloTargetOpacity,
  0.12
);

// üîë –ö–õ–Æ–ß
n.halo.visible = n.halo.material.opacity > 0.002;



    // --- Glow (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å) ---
   const baseIntensity = 0.05;
const baseDistance = 10;
let targetIntensity = baseIntensity;
let targetDistance = baseDistance;
if (n === hoveredNode) { targetIntensity = 0.15; targetDistance = 15; }
if (n.menuActive) { targetIntensity = Math.max(targetIntensity,0.35); targetDistance = Math.max(targetDistance,25); }
// –£—Å–∏–ª–µ–Ω–∏–µ Glow –Ω–∞ ~10%
n.glow.intensity = THREE.MathUtils.lerp(n.glow.intensity, targetIntensity * 1.1, 0.1);
n.glow.distance = THREE.MathUtils.lerp(n.glow.distance, targetDistance, 0.1);

});


    const sphereRadius = updateGraphAndSphere(time);

    nodes.forEach(n=>{
      if (!n.mesh || !n.halo) return;
        nodes.forEach(other=>{
            if(n===other) return;
            const dir = new THREE.Vector3().subVectors(n.mesh.position,other.mesh.position);
            const dist = dir.length();
            if(dist===0) return;
            const repulse = 0.1/dist; 
            dir.normalize().multiplyScalar(repulse);
            n.velocity.add(dir);
        });

        n.connectedLines.forEach(line=>{
            const other = line.userData.a===n?line.userData.b:line.userData.a;
            const dir = new THREE.Vector3().subVectors(n.mesh.position,other.mesh.position);
            const force = (n.status==='Red'?0.01:0.0025)*n.gravityForce; 
            dir.normalize().multiplyScalar(force);
            n.velocity.sub(dir);
            other.velocity.add(dir);
        });

        n.mesh.position.add(n.velocity);
        n.velocity.multiplyScalar(0.9); 
        n.driftPhaseX += n.driftSpeedX;
        n.driftPhaseY += n.driftSpeedY;
        n.mesh.position.x += Math.cos(n.driftPhaseX) * n.driftRadiusX;
        n.mesh.position.y += Math.sin(n.driftPhaseY) * n.driftRadiusY;
        n.glow.position.copy(n.mesh.position);
    });

nodes.forEach(node => {
    node.connectedLines.forEach(line => {
        const {a, b, segments} = line.userData;
        const pts = [];
const rA = a.radius * 1.05;
const rB = b.radius * 1.05;


for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const p = new THREE.Vector3().lerpVectors(a.mesh.position, b.mesh.position, t);
    const sag = Math.sin(Math.PI * t) * 0.5;
    p.y -= sag;

    // ‚ùå –ù–ï –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–Ω—É—Ç—Ä–∏ —Å—Ñ–µ—Ä—ã —É–∑–ª–∞
    if (
        p.distanceTo(a.mesh.position) < rA ||
        p.distanceTo(b.mesh.position) < rB
    ) {
        continue;
    }

    pts.push(p);
}
      
  if (pts.length >= 2) {
    line.geometry.setFromPoints(pts);
}


line.geometry.setFromPoints(pts);

      
        // ===== –ü—Ä–æ–≤–µ—Ä–∫–∞: –ª–∏–Ω–∏—è –ø—Ä–æ—Ö–æ–¥–∏—Ç —á–µ—Ä–µ–∑ —É–∑–µ–ª =====
const camPos = camera.position;
let nearNode = false;

for (let i = 0; i < pts.length; i++) {
    const p = pts[i];

    const dCam = p.distanceTo(camPos);
    const dA = p.distanceTo(a.mesh.position);
    const dB = p.distanceTo(b.mesh.position);

    if (
        (dA < a.mesh.scale.x * 1.05 && dCam > a.mesh.position.distanceTo(camPos)) ||
        (dB < b.mesh.scale.x * 1.05 && dCam > b.mesh.position.distanceTo(camPos))
    ) {
        nearNode = true;
        break;
    }
}


        // –¶–≤–µ—Ç –ª–∏–Ω–∏–∏ –ø–æ —Å—Ç–∞—Ç—É—Å—É —É–∑–ª–æ–≤
        const statuses = [a.status, b.status];
        if (statuses.includes('Red')) line.material.color.set(0xcc2222);
        else if (statuses.includes('Yellow')) line.material.color.set(0xffcc00);
        else line.material.color.set(0x00cc44);

        // ===== –ú–µ—Ä—Ü–∞–Ω–∏–µ + –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –ª–∏–Ω–∏–∏ –≤–æ–∑–ª–µ —É–∑–ª–æ–≤ =====
if (line.userData.phase === undefined)
    line.userData.phase = Math.random() * Math.PI * 2;

const pulseSpeed = 0.005;
const baseOpacity = 0.08;
const pulseAmplitude = 0.04;

line.material.opacity =
    (baseOpacity + pulseAmplitude * Math.sin(time * pulseSpeed + line.userData.phase)) * 1.1;

line.userData.phase += 0.001;

    });
});


    // ===== –°–ø–∏—Ä–∞–ª–∏ =====
    const redCount = countRedNodes();
    const redRatio = Math.min(redCount/nodes.length,1);
spiralBezelGroup.scale.set(
    sphereRadius * (1 + redRatio * 0.2),
    sphereRadius * (1 + redRatio * 0.2),
    sphereRadius * (1 + redRatio * 0.2)
);
    spiralLines.forEach(obj=>{
        obj.line.rotation.z += obj.rotationSpeed / 2; 
        obj.phase += 0.01; 
        const startColor = new THREE.Color(0x00ffff);
        const midColor = new THREE.Color(0x33ccff);
        const alertColor = new THREE.Color(0xff4444);
        let color = startColor.clone().lerp(midColor, redRatio);
        if(redRatio>0.7) color.lerp(alertColor, (redRatio-0.7)/0.3);
        obj.line.material.color.set(color);
        obj.line.material.opacity = (0.1 + 0.05*Math.sin(obj.phase)) * 0.8;
    });

    // ===== –ß–∞—Å—Ç–∏—Ü—ã =====
    const positions = particleGeo.attributes.position.array;
for(let i=0;i<particles.length;i++){
    const p = particles[i];
    p.theta += p.speed;
    p.phi += p.speed*0.5;
    const rMax = 0.95 * sphereRadius * (1 + 0.05*Math.sin(time*0.002));
    positions[i*3] = p.r*rMax*Math.sin(p.phi)*Math.cos(p.theta);
    positions[i*3+1] = p.r*rMax*Math.sin(p.phi)*Math.sin(p.theta);
    positions[i*3+2] = p.r*rMax*Math.cos(p.phi);
}
particleGeo.attributes.position.needsUpdate = true;


// ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –º–µ–Ω—é =====
if (currentMenuNode) {
    updateMenuPosition(currentMenuNode, menuDiv);

    // ===== –ü—É–ª—å—Å –º–µ–Ω—é –ø–æ —Å—Ç–∞—Ç—É—Å—É —É–∑–ª–∞ =====
    const pulse = 0.05 * Math.sin(Date.now() * 0.005);
    const baseGlow = 0.15;
    let color;

    switch (currentMenuNode.status) {
        case 'Green': color = '0,204,68'; break;
        case 'Yellow': color = '255,204,0'; break;
        case 'Red': color = '204,34,34'; break;
    }

    menuDiv.style.boxShadow = `
        0 0 ${12 + pulse*12}px rgba(${color},${baseGlow + pulse}),
        inset 0 0 ${6 + pulse*6}px rgba(${color},${baseGlow + pulse*0.5})
    `;
}
    renderer.render(scene,camera);

    
}
animate();
// ===== –ö–ª–∏–∫ –∏ –º–∞—Å—à—Ç–∞–± =====

window.addEventListener('mousedown', event=>{
    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh), false)
        .filter(i => !i.object.userData.isHalo);
    if(intersects.length===0) {
    // –ù–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å —É–∑–ª–∞–º–∏
    if(event.button === 2){ // –ü–ö–ú
        const now = performance.now();
        if(!window.lastContextMenuClickTime) window.lastContextMenuClickTime = 0;
        if(now - window.lastContextMenuClickTime < 300){ // –¥–≤–æ–π–Ω–æ–π –ü–ö–ú
            // –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—à–µ –º–µ–Ω—é –∑–∞–¥–∞—á
            openSideMenu(event.clientX, event.clientY);
            window.lastContextMenuClickTime = 0;
        } else {
            window.lastContextMenuClickTime = now;
        }
    }
    return; // —á—Ç–æ–±—ã –Ω–µ –≤—ã–ø–æ–ª–Ω—è–ª–∏—Å—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
}
    const clickedNode = nodes.find(n=>n.mesh===intersects[0].object);

    if(event.button===0){
        // –õ–µ–≤—ã–π –∫–ª–∏–∫ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Å—Å—ã–ª–∫—É
      /*
        window.on(clickedNode.link,"_blank");
        */
    } else if(event.button===2){
        // –ü—Ä–∞–≤—ã–π –∫–ª–∏–∫ –º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ç—É—Å
        clickedNode.status = clickedNode.status==='Green'?'Yellow':clickedNode.status==='Yellow'?'Red':'Green';
        saveNodesState();
    } 
});



window.addEventListener('wheel', event => {
    camera.position.z += event.deltaY * 0.05;
    camera.position.z = Math.min(Math.max(camera.position.z, 5), 1000);
});


window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});

window.addEventListener('contextmenu',e=>e.preventDefault());

// ===== –ü–æ–ª–∑—É–Ω–æ–∫ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∞ =====
const scaleSlider = document.getElementById('scaleSlider');
scaleSlider.addEventListener('input', () => {
    const scaleValue = parseFloat(scaleSlider.value);
    modelGroup.scale.set(scaleValue, scaleValue, scaleValue);
});
  
  
  
  
const labelsContainer = document.getElementById('nodeLabels');
let labelsEnabled = false;

function createNodeLabel(node) {
  const el = document.createElement('div');
  el.className = 'node-label';
  labelsContainer.appendChild(el);

  node.label = {
    el,
    x: 0,
    y: 0
  };
}

  
  
  
// ======== –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —É–∑–ª–æ–≤ (–∏–º—è, —Å—Ç–∞—Ç—É—Å, —á–µ–∫–ø–æ–∏–Ω—Ç—ã, —Ç–µ–∫—Å—Ç—ã) ========
function saveNodesState() {
  const data = nodes.map(n => ({
    id: n.id,
    name: n.name,
    status: n.status,
    checkpoints: n.checkpoints,
    tasks: n.tasks,
    isHighlighted: n.isHighlighted   // ‚Üê –î–û–ë–ê–í–ò–¢–¨

  }));
  localStorage.setItem('graphNodesState', JSON.stringify(data));
}

function loadNodesState() {
  const raw = localStorage.getItem('graphNodesState');
  if (!raw) return;

  let data;
  try {
    data = JSON.parse(raw);
  } catch {
    return;
  }

  data.forEach(savedNode => {
    const node = nodes.find(n => n.id === savedNode.id);
    if (!node) return;

    node.name = savedNode.name ?? node.name;
    node.status = savedNode.status ?? node.status;
    node.checkpoints = savedNode.checkpoints ?? node.checkpoints;
    node.tasks = savedNode.tasks ?? [];

    // ‚¨á –¢–û–õ–¨–ö–û –°–û–°–¢–û–Ø–ù–ò–ï
    node.isHighlighted = !!savedNode.isHighlighted;
  });

  nodes.forEach(node => {
    updateNodeStatusByTasks(node);
    applyNodeColor(node);
  });
}

  
console.log(
  'TASKS SNAPSHOT:',
  nodes.map(n => ({
    node: n.id,
    tasks: n.tasks
  }))
);



setInterval(() => {
  nodes.forEach(node => {
    updateNodeStatusByTasks(node);
    applyNodeColor(node);
  });
}, 1000);

  
  
function updateNodeStatusByTasks(node) {
  if (!Array.isArray(node.tasks) || node.tasks.length === 0) {
    node.status = 'Green';
    return;
  }

  // üî¥ 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ä–æ—á–Ω—ã—Ö –∑–∞–¥–∞—á (–≤—Ä–µ–º—è / –≤—Å—Ç—Ä–µ—á–∞)
  const hasUrgent = node.tasks.some(
    t => !t.completed && isTaskUrgentNow(t)
  );

  if (hasUrgent) {
    node.status = 'Red';
    return;
  }

  // üü° 2. –û–±—ã—á–Ω—ã–µ –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏
  const hasUnfinished = node.tasks.some(t => !t.completed);
  node.status = hasUnfinished ? 'Yellow' : 'Green';
}

  
  

function isTaskUrgentNow(task) {
  if (task.completed) return false;

  const now = new Date();
  const hour = now.getHours();

  // ===== üî¥ –í–°–¢–†–ï–ß–ê =====
  if (task.type === '–≤—Å—Ç—Ä–µ—á–∞' && task.meetingTime) {
    const [h, m] = task.meetingTime.split(':').map(Number);
    const meeting = new Date();
    meeting.setHours(h, m, 0, 0);

    const diffHours = (meeting - now) / (1000 * 60 * 60);
    return diffHours > 0 && diffHours <= 3;
  }

  // ===== üî¥ –ü–ï–†–ò–û–î –î–ù–Ø =====
  if (task.dayTime) {
    if (task.dayTime === '—É—Ç—Ä–æ') {
      return hour >= 3 && hour < 9;
    }
    if (task.dayTime === '–¥–µ–Ω—å') {
      return hour >= 9 && hour < 15;
    }
    if (task.dayTime === '–≤–µ—á–µ—Ä') {
      return hour >= 15 && hour < 21;
    }
  }

  return false;
}


  
  
  
  

function applyNodeColor(node) {
  const colorMap = {
    Green: 0x00cc44,
    Yellow: 0xffcc00,
    Red: 0xcc2222
  };

  if (node.mesh && node.mesh.material) {
    node.mesh.material.color.set(colorMap[node.status]);
    node.mesh.material.needsUpdate = true;
  }
}

  
  
function debugNode(node) {
  console.log(
    node.tasks.map(t => ({
      name: t.name,
      urgent: isTaskUrgentNow(t),
      type: t.type,
      dayTime: t.dayTime,
      datetime: t.datetime
    }))
  );
}
 


  
  
  
// –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ

  
function loadTaskHistory() {
  const list = document.getElementById('taskHistoryList');
  if (!list) return;

  list.innerHTML = '';

  const history = JSON.parse(
    localStorage.getItem(TASK_HISTORY_KEY) || '[]'
  );

  history
    .filter(item =>
      activeHistoryNode === 'ALL' || item.node === activeHistoryNode
    )
    .forEach(item => {
      const row = document.createElement('div');
      row.className = 'task-history-item';

      row.innerHTML = `
        <div class="task-history-time">${item.time}</div>
        <div class="task-history-task">${item.task}</div>
        <div class="task-history-node">${item.node}</div>
      `;

      list.appendChild(row);
    });
}


 
loadNodesState();
loadTaskHistory();

document.addEventListener('DOMContentLoaded', () => {
  
  
// ===== –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ =====

loadTaskHistory();
buildHistoryTabs();

  
// ===== –¢–µ–º—ã –ø–∞–Ω–µ–ª–∏ =====
const themes = [
  'theme-green',
  'theme-yellow',
  'theme-purple',
  'theme-blue',
  'theme-gray',
  'theme-black'
];

const panel = document.getElementById('taskHistoryPanel');
const toggleThemeBtn = document.getElementById('toggleTheme');

if (panel) {
  const savedTheme = localStorage.getItem('taskHistoryTheme');
  const initialTheme = themes.includes(savedTheme)
    ? savedTheme
    : themes[0];

  panel.classList.add(initialTheme);
  localStorage.setItem('taskHistoryTheme', initialTheme);
}

if (toggleThemeBtn && panel) {
  toggleThemeBtn.addEventListener('click', () => {

    const currentTheme = localStorage.getItem('taskHistoryTheme');
    const currentIndex = themes.indexOf(currentTheme);
    const nextIndex = (currentIndex + 1) % themes.length;
    const nextTheme = themes[nextIndex];

    themes.forEach(t => panel.classList.remove(t));
    panel.classList.add(nextTheme);

    localStorage.setItem('taskHistoryTheme', nextTheme);
  });
}

  
  
  

  // ===== –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–ø–∏—Å—å (Undo) =====
  const deleteHistoryBtn = document.getElementById('deleteLastHistory');

  if (deleteHistoryBtn) {
    deleteHistoryBtn.addEventListener('click', () => {
      const history = JSON.parse(
        localStorage.getItem(TASK_HISTORY_KEY) || '[]'
      );

      if (history.length === 0) return;

      history.shift();

      localStorage.setItem(
        TASK_HISTORY_KEY,
        JSON.stringify(history)
      );

      loadTaskHistory();
    });
  }

  // ===== –≠–∫—Å–ø–æ—Ä—Ç –±–µ–∫–∞–ø–∞ =====
  const exportBtn = document.getElementById('exportBackup');

  if (exportBtn) {
    exportBtn.addEventListener('click', () => {

      const backup = {};

      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        backup[key] = localStorage.getItem(key);
      }

      const blob = new Blob(
        [JSON.stringify(backup, null, 2)],
        { type: 'application/json' }
      );

      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'graph-backup.json';
      a.click();

      URL.revokeObjectURL(url);
    });
  }

  // ===== –ò–º–ø–æ—Ä—Ç –±–µ–∫–∞–ø–∞ =====
  const importBtn = document.getElementById('importBackup');
  const fileInput = document.getElementById('backupFileInput');

  if (importBtn && fileInput) {

    importBtn.addEventListener('click', () => {
      fileInput.value = '';
      fileInput.click();
    });

    fileInput.addEventListener('change', () => {
      const file = fileInput.files[0];
      if (!file) return;

      const reader = new FileReader();

      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);

          localStorage.clear();

          for (const key in data) {
            localStorage.setItem(key, data[key]);
          }

          alert('–ë–µ–∫–∞–ø –∑–∞–≥—Ä—É–∂–µ–Ω. –°—Ç—Ä–∞–Ω–∏—Ü–∞ –±—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω–∞.');
          location.reload();

        } catch (e) {
          alert('–û—à–∏–±–∫–∞: —Ñ–∞–π–ª –±–µ–∫–∞–ø–∞ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω');
        }
      };

      reader.readAsText(file);
      
      
    });
  }

});

  


  

// –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ —á–µ—Ä–µ–∑ –ø—Ä–∞–≤—ã–π –∫–ª–∏–∫
window.addEventListener('mousedown', event => {
    if(event.button === 2){ // –ø—Ä–∞–≤—ã–π –∫–ª–∏–∫
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh));
        if(intersects.length === 0) return;
        const clickedNode = nodes.find(n => n.mesh === intersects[0].object);
        clickedNode.status = clickedNode.status==='Green' ? 'Yellow' : clickedNode.status==='Yellow' ? 'Red' : 'Green';
        saveNodesState();
    }
});

// –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∏–º–µ–Ω–∏ —á–µ—Ä–µ–∑ input
nodeNameInput.addEventListener('input', () => {
    if(currentMenuNode){
        currentMenuNode.name = nodeNameInput.value;
        saveNodesState();
    }
});



// ===== –§—É–Ω–∫—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é Add Task =====
function openAddTaskMenu(x, y) {
    const menu = document.getElementById('addTaskMenu');
    menu.style.display = 'block';
    menu.style.opacity = '1';
    menu.style.left = `${x - menu.offsetWidth / 2}px`;
    menu.style.top = `${y - menu.offsetHeight / 2}px`;

    // –û—á–∏—â–∞–µ–º –ø–æ–ª—è –≤–Ω—É—Ç—Ä–∏ –º–µ–Ω—é
    const inputs = menu.querySelectorAll('input');
    inputs.forEach(input => {
        if (input.type === 'checkbox' || input.type === 'radio') {
            input.checked = false;
        } else {
            input.value = '';
        }
    });

    showTaskSettings(); // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–ª–æ–∫–∏ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Ä–∞–¥–∏–æ–∫–Ω–æ–ø–∫–µ
}


// ===== –ú–∞—Å—Å–∏–≤ —É–∑–ª–æ–≤ –≥—Ä–∞—Ñ–∞ =====
const graphNodes = [
    { id: 'node1', name: '–°–µ–º—å—è' },
    { id: 'node2', name: '–ó–¥–æ—Ä–æ–≤—å–µ' },
    { id: 'node3', name: '–†–∞–±–æ—Ç–∞' },
    { id: 'node4', name: '–ü—Ä–∏–≤—ã—á–∫–∏' },
    { id: 'node5', name: '–ü–æ—Ä—è–¥–æ–∫' },
    { id: 'node6', name: '–ë–∏–∑–Ω–µ—Å' },
    { id: 'node7', name: '–î–æ–ª–≥–∏' },
    { id: 'node8', name: '–î—Ä—É–∑—å—è' },
    { id: 'node9', name: '–ß—Ç–µ–Ω–∏–µ' },
    { id: 'node10', name: '–ù–∞–≤—ã–∫–∏' },
    { id: 'node11', name: '–ó–Ω–∞–Ω–∏—è' },
    { id: 'node12', name: "3DProject's" },
    { id: 'node13', name: '–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è' },
    { id: 'node14', name: '–¢–≤–æ—Ä—á–µ—Å—Ç–≤–æ' },
    { id: 'node15', name: '–ù–∞–º–µ—Ä–µ–Ω–∏—è' }
];
  
// === –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è graphNodes —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ —É–∑–ª–∞–º–∏ ===
graphNodes.forEach(gNode => {
  const realNode = nodes.find(n => n.id === gNode.id);
  if (realNode && realNode.name) {
    gNode.name = realNode.name;
  }
});

// UI –æ–±–Ω–æ–≤–ª—è–µ–º –¢–û–õ–¨–ö–û –ø–æ—Å–ª–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
renderTaskNodeList();
  
function startRenameSelectedNode() {
  
    // ‚õî –∂—ë—Å—Ç–∫–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª—é–±—ã–µ pending long-press
  if (renameTimer) {
    clearTimeout(renameTimer);
    renameTimer = null;
  }

  longPressTriggered = false;

  if (isRenamingNode) return;
  isRenamingNode = true;
  
  
  
  longPressBar.style.transition = 'none';
  longPressBar.style.width = '0%';

  
const node = graphNodes.find(n => n.id === selectedTaskNodeId);
if (!node) {
  isRenamingNode = false;   // ‚¨Ö –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û
  return;
}


  const input = document.createElement('input');
  input.type = 'text';
  
  input.style.position = 'absolute';
  input.style.right = '0';
  input.style.top = '50%';
  input.style.transform = 'translateY(-50%)';

  input.style.width = '160px';
  input.style.fontSize = '12px';
  input.style.zIndex = '10';

  
  input.value = node.name;
  input.style.width = '100%';
  input.style.boxSizing = 'border-box';

  selectedLabel.textContent = '';
  selectedLabel.appendChild(input);
  selectedLabel.appendChild(longPressBar); // ‚¨Ö –í–ê–ñ–ù–û

  function save() {
  const newName = input.value.trim();
  if (!newName) {
    selectedLabel.textContent = node.name;
    return;
  }

  node.name = newName;

  const realNode = nodes.find(n => n.id === node.id);
  if (realNode) realNode.name = newName;

  saveNodesState();
  selectedLabel.textContent = newName;
  renderTaskNodeList();
}

  
  input.focus();
  input.addEventListener('blur', () => {
  save();
  isRenamingNode = false; // ‚¨Ö –í–ê–ñ–ù–û
  longPressTriggered = false;

  if (renameTimer) {
    clearTimeout(renameTimer);
    renameTimer = null;
    }
});

  input.select();

  function save() {
    const newName = input.value.trim();
    if (!newName) {
      selectedLabel.textContent = node.name;
      return;
    }

    node.name = newName;

    const realNode = nodes.find(n => n.id === node.id);
    if (realNode) realNode.name = newName;

    saveNodesState();
    selectedLabel.textContent = newName;
    renderTaskNodeList();
  }

input.addEventListener('keydown', e => {
  if (e.key === 'Enter') input.blur();

  if (e.key === 'Escape') {
    selectedLabel.textContent = node.name;
    isRenamingNode = false; // ‚¨Ö –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û
  }
});

}



  
  
function renderTaskNodeList() {
  const list = document.getElementById('taskNodeList');
  list.innerHTML = '';

  graphNodes.forEach(node => {
    const item = document.createElement('div');
    item.className = 'node-item';
    item.textContent = node.name;
    item.dataset.id = node.id;

item.addEventListener('click', () => {

  // ‚õî –ü–û–õ–ù–´–ô –°–ë–†–û–° rename-—Å–æ—Å—Ç–æ—è–Ω–∏—è
  if (renameTimer) {
    clearTimeout(renameTimer);
    renameTimer = null;
  }

  isRenamingNode = false;
  longPressTriggered = false;

  longPressBar.style.transition = 'none';
  longPressBar.style.width = '0%';

  // ‚úÖ —Ç–µ–ø–µ—Ä—å –±–µ–∑–æ–ø–∞—Å–Ω–æ –º–µ–Ω—è—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π —É–∑–µ–ª
  selectedTaskNodeId = node.id;

  selectedLabel.textContent = node.name;
  list.style.display = 'none';

  document.querySelectorAll('.node-item').forEach(el => {
    el.classList.toggle('selected', el.dataset.id === node.id);
  });
});

    list.appendChild(item);
  });
}


renderTaskNodeList();
  



  
  
const tasks = [];



// –ó–∞–∫—Ä—ã—Ç–∏–µ Add Task
function closeAddTaskMenu() {
  const menu = document.getElementById('addTaskMenu');
  menu.style.display = 'none';
}

// –ü–æ–∫–∞–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
function showTaskSettings() {
  const taskType = document.querySelector('input[name="taskType"]:checked')?.value;
  document.getElementById('taskSettings').style.display = (taskType==='–∑–∞–¥–∞—á–∞')?'block':'none';
  document.getElementById('habitSettings').style.display = (taskType==='–ø—Ä–∏–≤—ã—á–∫–∞'||taskType==='–ø–ª–∞–Ω')?'block':'none';
  document.getElementById('meetingSettings').style.display = (taskType==='–≤—Å—Ç—Ä–µ—á–∞')?'block':'none';
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏
function saveTask() {
  const taskName = document.getElementById('taskName').value;
  const taskType = document.querySelector('input[name="taskType"]:checked')?.value;
  const node = selectedTaskNodeId;

  if(!taskName){ alert("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏!"); return; }
  if(!node){ alert("–í—ã–±–µ—Ä–∏—Ç–µ —É–∑–µ–ª!"); return; }

  let taskData = {
  name: taskName,
  type: taskType,
  node: node,
  completed: false,
  link: null // ‚¨Ö –°–°–´–õ–ö–ê –ù–ê OBSIDIAN
};



  if(taskType==='–∑–∞–¥–∞—á–∞'){
    taskData.effort = document.querySelector('input[name="effort"]:checked')?.value;
    taskData.time = document.querySelector('input[name="time"]:checked')?.value;
  } // ===== –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–æ–∂–Ω–æ—Å—Ç—å –∑–∞–¥–∞—á–∏ =====
  if(taskType === '–∑–∞–¥–∞—á–∞'){
  const effort = taskData.effort === '—Ç—Ä–µ–±—É–µ—Ç —É—Å–∏–ª–∏–π';
  const time = taskData.time === '–Ω—É–∂–Ω–æ –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏';

  if(!effort && !time){
    taskData.difficulty = '–ª—ë–≥–∫–∞—è';
  } else if(effort && time){
    taskData.difficulty = '—Å–ª–æ–∂–Ω–∞—è';
  } else {
    taskData.difficulty = '—Å—Ä–µ–¥–Ω—è—è';
  }
}

    else if(taskType==='–ø—Ä–∏–≤—ã—á–∫–∞'||taskType==='–ø–ª–∞–Ω'){
    taskData.dayTime = document.querySelector('input[name="dayTime"]:checked')?.value;
    taskData.days = Array.from(document.querySelectorAll('input[name="days"]:checked')).map(d=>d.value);
    taskData.duration = document.querySelector('input[name="duration"]:checked')?.value;
      
  } else if(taskType === '–≤—Å—Ç—Ä–µ—á–∞'){
  taskData.date = document.getElementById('meetingDate')?.value;
  taskData.meetingTime = document.getElementById('meetingTime')?.value;
  taskData.comment = document.getElementById('taskComment')?.value;
}


const nodeObj = nodes.find(n => n.id === node);
if (nodeObj) {
  // –Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –≤—Å–µ–≥–¥–∞ —Å–≤–µ—Ä—Ö—É
  nodeObj.tasks.unshift(taskData);
  saveNodesState();
}

  if(currentMenuNode){
  updateNodeTasks(currentMenuNode);
}
  closeAddTaskMenu();
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ –º–µ–Ω—é —É–∑–ª–∞
function addTaskToNodeMenu(taskName, nodeId){
  const tasksList = document.getElementById('nodeTasksList');
  if(!tasksList) return;

  const taskItem = document.createElement('div');
  taskItem.textContent = taskName;
  taskItem.style.padding = '2px 0';
  taskItem.style.fontSize = '13px';
  taskItem.style.color = '#ccffcc';

  tasksList.appendChild(taskItem);
}

// –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∫–ª–∏–∫–∏ –≤–Ω—É—Ç—Ä–∏ –º–µ–Ω—é
function preventMenuClick(menuId){
  const menu = document.getElementById(menuId);
  ['mousedown','mouseup','click'].forEach(evt=>{
    menu.addEventListener(evt,e=>e.stopPropagation());
  });
}

preventMenuClick('addTaskMenu');
preventMenuClick('nodeMenu');

// –û—Ç–∫—Ä—ã—Ç–∏–µ Add Task –ø–æ Enter, –∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ Escape
window.addEventListener('keydown', (event)=>{
  if(event.key==="Enter"){
    openAddTaskMenu(window.innerWidth/2, window.innerHeight/2);
  } else if(event.key==="Escape"){
    closeAddTaskMenu();
  }
});
  
  
  const toggle = document.getElementById('tasksToggle');
const extra = document.getElementById('nodeTasksExtra');

if (toggle && extra) {
  toggle.addEventListener('click', () => {
    const opened = extra.style.display === 'block';

    extra.style.display = opened ? 'none' : 'block';
    toggle.textContent = opened ? '‚ñ∂' : '‚óÄ';
  });
}
  

const dropdown = document.getElementById('taskNodeDropdown');
const selectedLabel = document.getElementById('taskNodeSelected');
const longPressBar = document.createElement('div');
longPressBar.className = 'longpress-progress';
selectedLabel.appendChild(longPressBar);
  

const list = document.getElementById('taskNodeList');
  
let renameTimer = null;
let isRenamingNode = false;
let longPressTriggered = false;



selectedLabel.addEventListener('mousedown', () => {
  if (!selectedTaskNodeId) return;
  if (isRenamingNode) return;
  if (renameTimer) return; // ‚¨Ö –í–ê–ñ–ù–û


  longPressBar.style.transition = 'none';
  longPressBar.style.width = '0%';

  // –¥–∞—ë–º –±—Ä–∞—É–∑–µ—Ä—É –ø—Ä–∏–º–µ–Ω–∏—Ç—å 0%
  requestAnimationFrame(() => {
    longPressBar.style.transition = 'width 3s linear';
    longPressBar.style.width = '100%';
  });

renameTimer = setTimeout(() => {
  longPressTriggered = true;   // ‚¨Ö –ö–õ–Æ–ß–ï–í–û
  startRenameSelectedNode();
}, 3000);
  
});





document.addEventListener('mouseup', () => {
  clearTimeout(renameTimer);
  renameTimer = null;

  longPressBar.style.transition = 'none';
  longPressBar.style.width = '0%';

  // ‚¨Ö —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –§–õ–ê–ì –ü–û–°–õ–ï –ø–æ–ª–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
  setTimeout(() => {
    longPressTriggered = false;
  }, 0);
});


  
selectedLabel.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —É–∑–µ–ª';


selectedLabel.addEventListener('click', () => {
  if (longPressTriggered) {
    longPressTriggered = false; // —Å–±—Ä–∞—Å—ã–≤–∞–µ–º
    return; // ‚õî –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–µ–º dropdown
  }

  const opened = list.style.display === 'block';
  list.style.display = opened ? 'none' : 'block';
});

  
document.addEventListener('mousedown', e => {
  if (longPressTriggered) return; // ‚¨Ö –∑–∞—â–∏—Ç–∞

  if (!dropdown.contains(e.target)) {
    list.style.display = 'none';
  }
});

  let lastRightSideClickTime = 0;

window.addEventListener('mousedown', e => {
  if (e.button !== 0) return; // —Ç–æ–ª—å–∫–æ –õ–ö–ú

  // –ø—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞ (30%)
  if (e.clientX < window.innerWidth * 0.7) return;

  const now = performance.now();

  if (now - lastRightSideClickTime < 300) {
    toggleTaskHistoryPanel();
    lastRightSideClickTime = 0;
  } else {
    lastRightSideClickTime = now;
  }
});

  
  
  
  const deleteBtn = document.getElementById('deleteLastHistory');

if (deleteBtn) {
  deleteBtn.addEventListener('click', () => {

    const history = JSON.parse(
      localStorage.getItem(TASK_HISTORY_KEY) || '[]'
    );

    if (history.length === 0) return; // –Ω–µ—á–µ–≥–æ —É–¥–∞–ª—è—Ç—å

    history.shift(); // ‚¨Ö —É–¥–∞–ª—è–µ–º –ü–û–°–õ–ï–î–ù–Æ–Æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—É—é –∑–∞–ø–∏—Å—å

    localStorage.setItem(
      TASK_HISTORY_KEY,
      JSON.stringify(history)
    );

    loadTaskHistory(); // –æ–±–Ω–æ–≤–ª—è–µ–º –±–æ–∫–æ–≤–æ–µ –º–µ–Ω—é
  });
}

  
function buildHistoryTabs() {
  const tabs = document.getElementById('taskHistoryTabs');
  if (!tabs) return;

  tabs.innerHTML = '';

  // ===== –ö–Ω–æ–ø–∫–∞ "–í—Å–µ" =====
  const allTab = document.createElement('div');
  allTab.textContent = '–í—Å–µ';
  allTab.className = 'task-history-tab task-history-tab-all active';
  tabs.appendChild(allTab);

 allTab.onclick = () => {
  const tabs = document.getElementById('taskHistoryTabs');

  // –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ä–∞—Å–∫—Ä—ã—Ç–∏–µ
  tabs.classList.toggle('expanded');

  // –ª–æ–≥–∏–∫–∞ "–í—Å–µ"
  activeHistoryNode = 'ALL';
  updateActiveTab();
  loadTaskHistory();
};


  // ===== –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –≤–∫–ª–∞–¥–æ–∫ —É–∑–ª–æ–≤ =====
  const nodesContainer = document.createElement('div');
  nodesContainer.id = 'taskHistoryNodesTabs';
  tabs.appendChild(nodesContainer);

  // ===== –í–∫–ª–∞–¥–∫–∏ —É–∑–ª–æ–≤ =====
  nodes.forEach(node => {
    const tab = document.createElement('div');
    tab.textContent = node.name;
    tab.className = 'task-history-tab';

    tab.onclick = () => {
      activeHistoryNode = node.name;
      updateActiveTab();
      loadTaskHistory();
    };

    nodesContainer.appendChild(tab);
  });
}


  

  
  
function updateActiveTab() {
  document.querySelectorAll('.task-history-tab')
    .forEach(tab => {
      tab.classList.toggle(
        'active',
        tab.textContent === (activeHistoryNode === 'ALL' ? '–í—Å–µ' : activeHistoryNode)
      );
    });
}

  
  
  
 
</script>
  
  <script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js');
}
</script>
  
<div id="taskHistoryPanel">
  <div id="taskHistoryTabs"></div>
  <div id="taskHistoryTitle">–ó–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏</div>

  <div id="taskHistoryList"></div>
  
  <button id="deleteLastHistory" class="panel-action-button">
  –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–ø–∏—Å—å
</button>

<div class="panel-button-row">
  <button id="exportBackup" class="panel-action-button">
    –≠–∫—Å–ø–æ—Ä—Ç
  </button>

  <button id="importBackup" class="panel-action-button">
    –ò–º–ø–æ—Ä—Ç
  </button>
  
  <input
  type="file"
  id="backupFileInput"
  accept="application/json"
  style="display:none"
/>


  
</div>
<button id="toggleTheme" class="panel-action-button">
  –°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É
</button>



</div>

  
</body>
</html>
